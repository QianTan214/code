
MySQL
# ===================================================================================

没有多对多的关系
如果有，则需要在中间新建一个table，分别是一对多


show databases
use test
show tables
show tables from MySQL
select database() # 查看目前在哪个库
create stuinfo(
    id int,
    name varchar(20)
);

show tables
desc stuinfo # 查看表结构describe

insert into stuinfo (id,name) values (1,"john");

update stuinfo set name="mike" where id = 1;

delete from stuinfo where id = 1;

select version(); # 查看版本


DQL: data query language
DML: data manipulation lanuage
DDL: data define lanuage
TCL: transaction control language


alias:
使用as 或者 space都可

去重：
select distinct from

concat:
select concat("firstname","lastname") as name;
# null 和 任何 concat都为null

ifnull()函数：
select ifnull("salary", 0) as salary


模糊查询：
Like
in
between and
is null # 不可以用= null
is not null


逻辑运算符：
not
and
or


where id <> 99 # id != 99 都可


模糊查询like：

like "%a%" # 包含a
like "%a%e%" # 包含a和e，并且a在e之前

% 任意多字符
_一个字符
like "__a_e%"


转义\
like "_\_a_e%"
like "_$_a_e%" escape "$" # 设置转义符号


between and 增加简洁度


<=> 安全等于 可以判断null，用的不多


order by desc asc
一般放在语句最后
只有limit在order by后面
order by后面也可接函数，比如length等


select length(lastname) as 姓的长度 salary,from employees order by length(lastname) desc;






MySQL 函数
# ===================================================================================

单行函数：concat，length，ifnull
分组函数/统计函数




字符函数
# ===================================================================================


select concat("lastname","_","firstname") from employees;


length函数
字节长度

upper,lower函数
select upper/lower(lastname) from ...


substr, substring函数
select substr("hello",2) output;
select substr("hello",2,3) output;


instr函数
select instr("hello","ell") as output; # 结果2


trim函数
去掉前后空格
select trim("    hello ") as output; # 结果hello

select trim("a" from "aaaahelloaaaa") as output;


lpad函数(左填充)
select lpad("hello",10,"*") as output; # 结果*****hello


rpad函数(右填充)
select rpad("hello",10,"*") as output; # 结果hello*****


replace函数
select replace("helloaaa","hello","bbbbb") as output; # 结果bbbbbaaa


MySQL 数学函数
# ===================================================================================

round函数
round(-1.65) # -2
round(-1.45) # -1

select round(1.567,2) # 1.57


ceil函数
向上取整
select ceil(1.00) # 1

floor函数
向下取整
select ceil(9.99) # 9


truncate函数
截断
select truncate(1.69999,1) # 1.6


mod函数
取余
select mod(-10,-3) # -1
select mod(-10,3) # -1
结果正负看-10的符号


rand函数
获取0-1之间随机数



MySQL 日期函数
# ===================================================================================

now函数
select now（）


curdate函数
select curdate()

curtime函数
select curtime()

year函数
select year(now())
select year('1998-1-1')


month函数
select month(now())


month函数和monthtime函数
select month(now()) # 9
select monthname(now()) # september


str_to_date函数
select str_to_date('2000-1-1','%Y-%c-%d') as output

eg.
查找employee入职日期
select str_to_date('4-3 1991','%c-%d %Y');


date_format函数
select date_format(now(),'%y年%m月%d日')

datediff函数
select datediff(now(),'1995-1-1')



MySQL 其他函数
# ===================================================================================

select version();
select database();
select user();
select password("hello") # 对hello加密
select md5("hello") # 对hello加密




MySQL 流程控制函数
# ===================================================================================

if函数
select if(10>5,'bigger','smaller')


case函数
select salary 原始工资,department_id,
case department_id
when 30 then salary*1.1
when 40 then salary*1.2
when 50 then salary*1.3
else salary
end as 新工资
from employees;



按首字母排序和按单词排序不一样
按单词排序，第一个字母一样，看第二个
但首字母排序只看第一个



分组函数
# ===================================================================================
sum
avg
max
min
count # 非空值数量

max,min,count可以处理任何类型数据

以上分组函数都忽略null值

都可以搭配distinct使用，实现去重

sum和distinct搭配
select sum(distinct,salary) from employees;

count函数用的很多
count(*)用的很多

count数行数时，只要一行里有一个数值不是null，count就加一

select count(1) from employees;

效率：
myisam存储引擎下，count(*)效率高
innodb存储引擎下，count(*)效率和count(1)差不多




分组查询
# ===================================================================================

分组查询中筛选条件分为两类:
分组前筛选 原始表 放在group by前 用where
分组后筛选 分组后的结果集 放在group by后 用having

分组函数做条件肯定放在having语句中


分组前的筛选：
出现每个字样时，用group by

group by

select max(salary), job_id from employees group by job_id;

select count(*), location_id from departments group by location_id;


分组后的筛选：
select count(*), department_id from employees group by department_id
having count(*) > 2;
此时不能用where了，因为不在employees表里


规律：可以先写select from group by 然后再写where 或者 having count等


group by后面如果有多个，没有顺序要求


找“各个”，“每个”这样的字眼，然后select他们




连接查询/多表查询
# ===================================================================================

笛卡尔乘积现象原因：
没有有效的连接条件

sql92标准
sql99标准（推荐）


内连接：等值连接，非等值连接，自连接
外连接：左外，右外，全外
交叉连接




等值连接（sql92标准）
# ===================================================================================

给表起过别名alias之后，原始名就不能用了

select a, b from table1, table2 where ... = ...

每个城市group by city


三表连接：
select lastname,departmentname, city from employees e, departments d, locations l
where e.department_id = d.department_id
and d.location_id = l.location_id;

多表等值连接为多表的交集部分




非等值连接（sql92标准）
# ===================================================================================

等号换成大于小于非等于号的连接
或者用between and


自连接（sql92标准）
# ===================================================================================

在同一张表里查询

例子：查询员工名和上级的名称
使用sql92标准

select e.employee_id,e.last_name, m.manager_id, m.last_name
from employees e, employees m;
where e.manager_id = m.manager_id;


例子：查询员姓名中包含字符k的员工名和上级的名称
使用sql99标准

select e.last_name, m.last_name
from employees e
join employees m
on e.manager_id = m.manager_id
where e.last_name like %k%;


group by和having里最好不用用别名，mysql支持，其他很多不支持


两个表都有的item select时会有歧义，要用table.item来select


别名中有特殊符号如#，需要用单或双引号引用起来





等值连接（sql99标准）
# ===================================================================================

table 1 （inner） join table 2 on = 

inner 可省略，直接写join

inner join连接和sql92语法中的等值连接效果一样，都是查询交集



非等值连接（sql99标准）
# ===================================================================================

on salary between lowerest and highest



自连接（sql99标准）
# ===================================================================================

select e.lastname, m.lastname from employees e join employees m
on e.manager_id = m.employee_id
where e.lastname like '%k%'



外连接（sql99标准）
# ===================================================================================

应用场景：用于查询一个表中有，另一个表中没有

主表，从表

外连接显示主表中所有记录，如果从表中有和它匹配的，则显示匹配的值。
如果主表中有，从表中没有和它匹配的，则显示null

外连接显示结果 = 内连接结果 + 主表有从表没有的记录

left join左边是主表
right join右边是主表

左外和右外两个表顺序交换，能达到一样的效果


要查询的信息在哪个表一般就是主表


例子：查询男朋友不在男神表的女神名
使用left outer join

select * from beauty;
select * from boys;

select b.name, bo.*
from beauty b
left outer join boys bo
on b.boyfriend_id = bo.id
where bo.id is null;



例子：查询男朋友不在男神表的女神名
使用right outer join

select * from beauty;
select * from boys;

select b.name, bo.*
from boys bo
right outer join beauty b
on b.boyfriend_id = bo.id
where bo.id is null;



例子：查询哪个部门没有员工
使用left outer join

select d.*, e.employee_id 
from departments d
left outer join employees e
on d.department_id = e.department_id
where e.employee_id is null;




全外连接（mysql不支持）
# ===================================================================================

full outer join

不分主从表

外连接显示结果 = 内连接结果 + 主表有从表没有的记录 + 从表中有主表中没有的记录




交叉连接（sql99标准）
# ===================================================================================

cross join
不用on

两个表进行笛卡尔乘积

select b.*, bo.*
from beauty b
cross join boys bo;

cross join就是92语法中的逗号



去掉交集（sql99标准）
# ===================================================================================

左外去交集
select from left join on where b.key is null;

右外去交集
select from right join on where a.key is null;

全外去交集
select from full join on where a.key is null or b.key is null;



子查询subquery（sql99标准）
# ===================================================================================

标量子查询（单行子查询）
列子查询（多列子查询）
行子查询（所行多列）

子查询放在小括号内
子查询一般放在条件右侧

列子查询一般搭配in any/some all使用
使用any可以用其他的来代替，如min，max等

having和where后都可接子查询

不等于<>

distinct去重

in可以换成=any
not in可以换成<>all

select后面也可有子查询，但不常用，比较别扭

from后面也可有子查询，表必须起别名


exists用的也比较少
exists后面可有子查询

exists（完整查询语句）
结果1或0

where exists/where not exist
能用exists都能用in




子查询subquery练习题（sql99标准）
# ===================================================================================
youtube视频98



分页查询（sql99标准）
# ===================================================================================

一页显示不全，需要分页提交sql请求


offset：要显示条目的起始索引，从0开始
size：要显示的条目个数


limit 0，5 # 起始0，共5
limit 5 # 默认index 0

limit 11，15 # 第11到25条目

limit (page - 1)*size, size;



联合查询（sql99标准）
# ===================================================================================

union

和or相似

union左右分别有一个select语句

union应用场景：
想查询的信息一致，且来自多个表，并且想查询的信息之间没关系时

如：查询中国用户中男性信息以及外国用户中男性信息


union查询特点：
多条查询语句的查询列数一样
要求多条查询语句要查询的的每一列的类型和顺序一致
union默认去重
union all可以包含重复项




insert插入
# ===================================================================================

方法一：
insert into 表名（列名。。。） values （值。。。）

照片类型blob

insert into beauty(id, name, photo, boy_friend_id) values (13, "alice", null, 2);

默认是nullable


insert into beauty(id, name, boy_friend_id) values (13, "alice", 2);
列也不写，null也不写


列的顺序可颠倒，只要值和列名一一对应

列数和值数的个数必须一致

可以不写列名，但值名必须全写
insert into beauty values (13, "alice", null, 2)



方法二：
insert into beauty set id=3, name = "bob", photo = null, boy_friend_id = 4;

insert into 也可以和set一起用
但每次只能插入一行


方法一可一次插入多个记录
insert into beauty values 
(13, "alice", 2),
(14, "bob", 2),
(15, "charlie", 2);


方法一支持子查询




update修改
# ===================================================================================

修改单表记录：

update 表名 set 列=新值 where 筛选条件

update beauty set phone = "1234567" where name like "%唐"


修改多表记录（涉及表的连接）：
update boys bo inner join beauty b on bo."id" = b."boy_friend_id"
set b."phone" = "123"
where bo."boyname" = "张无忌";





delete删除
# ===================================================================================


单表删除

多表删除
用join



truncate删除
# ===================================================================================

truncate table boys;
truncate后面不能加条件


autoincrement两者不同

用delete删除后，再插入数据，自增长列的值从断点开始
用truncate删除后，再插入数据，自增长列的值从1开始


truncate删除没有返回值，delete有

truncate删除不能回滚，delete可以

 

use table
desc table
show tables


DDL
# ===================================================================================


库：

创建库
create database name;
create database if not exists name;

修改库
更改库的字符集
alter database books character set gbk;

删除库
drop database books;
drop database if exists books;




表：

创建表
create table authors(
    id int,
    author varchar(20),
    nation varchar(20)
);



修改表
修改列名
alter table book change column publishdate publishdate datetime;

修改列的类型或者约束
alter table book modify column pudate timestamp;

添加新的列
alter table author add column annual double;

删除列
alter table authors drop column annual;

修改表名
alter table authors rename to book_author;


表总结：alter table 表名 add|drop|modify|change column 列名 列类型 约束；



删除表
drop table 表名
drop table if exists authors;

shows tables；


通常写法：先删除旧的
drop database if exists 就库名
create database 新库名

drop table if exists 旧表名
create table 表名()





表的复制
# ===================================================================================

仅仅复制表的结构
create table copied_table like authors;

复制结构加数据
create table copied_table
select * from authors;

只复制部分数据
加where

仅仅复制部分结构，不复制数据
create table copied_table
select id, name from authors
where 1 = 2; / where 0;


跨库复制表结构，可以用 database名.table名




数据类型介绍
# ===================================================================================

整型

小数：定点数，浮点数

字符型：较短文本char，varchar， 较长文本：text，blob（较长的二进制数据）

日期型


tinyint 有符号：-128 - 127 无符号: 0 - 255

create table tablename (
    t1 int,
    t2 int unsigned
)


create table tablename (
    t1 int(7) zerofill,
    t2 int(7) zerofill
)

长度代表显示的最大长度
如插入123， 则前四位用0补齐，0000123





常见约束
# ===================================================================================

六大约束
not null
default
primary key: 有唯一性，非空
unique:可以为空
check： 检查约束，mysql不支持
foreign key外键，在从表添加外键约束，引用主表值

设计表时或者修改表时添加约束


列级约束：六大约束都支持，但外键约束没效果
表级约束：除了非空，默认，其他都支持





约束
# ===================================================================================

创建表时添加约束
show index from tablename;
会列出所有主键，外键，unique的值的列

添加列级约束在列的后面加
不可以起约束名

添加表级约束在所有列的后面加
可以起约束名

表级约束默认和非空不支持


eg.
constraint uq unique (seat) # constraint uq 可省略，相当于没起名，系统有个默认名字
constraint fk_student_info_major foreign key (majorid) references major(id) # 同上


一般外键用表级约束，其他用列级约束



主键和唯一差别
# ===================================================================================

一个表中主键可以没有，可以一个，不可有多个

可以组合主键，但不推荐



外键特点
# ===================================================================================

在从表设置外键
引用的关联的主表里的列是主键或者是唯一键
添加数据时，先添加主表，再添加从表
删除数据时，先删除从表，再删除主表

添加非空约束
alter table tablename modify column columnname varchar(20) not null;

因为主键/唯一键支持列级和表级约束，所以两种写法
alter table tablename modify column id int primary key;

alter table stuinfo add primary key (列名);

可以add column, add constraint




标识列auto_increment
# ===================================================================================

show variables like "%auto_increment%" # 查看变量

可以更改起始值和步长

一个表最多一个auto_increment列

标识列一般int，也可以是float类型

set auto_increment_increment = 3; # 修改步长




TCL
# ===================================================================================

transaction control language
事务控制语言


事务：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全不执行

如果某条sql语句执行执行，整个单元将回滚

mysql中不同的存储引擎
show engines; # 查看存储引擎

innodb, myisam, memory等

事务的特性：ACID
atomicity
consistency
isolation
durability




事务
# ===================================================================================

隐性事务

显式事务：事务具有明显开始结束标志
前提：必须先设置自动提交功能为禁用
set autocommit = 0; # 只针对当前事务有效，并不永久


步骤：

开启事务：
set autocommit = 0;
start transaction; # 可选

编写事务中sql语句（select，insert， update， delete）

结束事务
commit提交事务
rollback回滚事务


commit之后就不能rollback了



数据库的隔离级别：

脏读
不可重复读
幻读

mysql支持4种事务隔离级别，默认的为repeatable read（可重读）





savepoint节点名的使用
# ===================================================================================

set autocommit = 0;
start transaction;

delete from account where id=1;
savepoint a; # 设置保存点
delete from account where id=2;
rollback to a; # 回滚到保存点

最终结果id=1删了，id=2没删

savepoint搭配rollback一起用




视图的介绍view
# ===================================================================================

视图相当于把查询语句包装起来

临时生成的表

虚拟表，和普通表一样使用

mysql15.1版本出现的新特性，通过表动态生成的数据

普通班和舞蹈班的例子

视图在mysql软件中是个眼镜标志

create view v1 as select ...




创建和使用视图
# ===================================================================================

create view 示图名
as
查询语句;

创建: create view myv1 as select ...
使用: select * from myv1 where ...


view也就是一个table

view可以接.
如myv1."av_salary"



视图的好处：
重用sql语句
简化sql操作
保护数据，提高安全性




修改视图
# ===================================================================================

方法一：

create or replace view 视图名
as 
查询语句；

如果不存在，create
如果存在，replace


方法二：

alter view 视图名
as
查询语句;




删除和查看视图
# ===================================================================================

drop view myv1, myv2...

方法一：

desc myv3;


方法二：

下面的最好在cmd中用：
show create view myv3;
show create view myv3\G; (格式一下)



更新视图
# ===================================================================================

一般更改视图view, 原始表也会改

包含以下关键字的sql语句，view不可更改：

distinct, group by, having, union, union all
select中包含子查询
join
from一个不能更新的视图



select后面是table才加from
select后如果直接是数据不加from



视图和表的区别
# ===================================================================================

create view / create table
视图view保存逻辑，不保存内容，占用内存小，基本没占用

table可以增删改查
视图一般不能增删，一般就是用来查询的




delete和truncate在事务中的区别
# ===================================================================================

delete没有删除表

set autocommit=0;
start transaction;
delete from account;
rollback;



truncate删除表了

set autocommit=0;
start transaction;
truncate from account;
rollback;






变量
# ===================================================================================

系统变量：属于服务器层面
全局变量
会话变量

自定义变量：
用户变量
局部变量




系统变量
# ===================================================================================

不写默认session


查看所有系统变量
show global variables;
show session variables;

查看满足条件的部分系统变量
show global variables like "%char%";
show session variables like "%char%";

查看某个指定的系统变量
select @@global.系统变量名
select @@session.系统变量名


为某个系统变量赋值
方法一：
set global 系统变量名=值


方法二：
set @@global.系统变量名=值
如
set @@global.autocommit = 0;



全局变量如tx_isolation,autocommit,auto_increment_increment,auto_increment_offset等

全局变量作用域：服务器每次启动将为所有全局变量赋初始值，不能跨重启，重启完会复原




会话变量
# ===================================================================================


会话变量作用域：仅仅针对当前会话（连接）有效

查看所有会话变量
show variables;

查看满足条件的部分会话变量
show variables like "%char%"
show session variables like "%char%"
session可省


查看某个指定的会话变量
select @@tx_isolation
select @@session.tx_isolation


为某个会话变量赋值
方法一：
set @@session.tx_isolation = "read-uncommitted";

方法二：
net session tx_isolation = "read-committed";




自定义变量
# ===================================================================================

用户变量
作用域：针对当前会话有效,可以应用在任何地方，begin end的里面或外面

1. 声明并初始化：=或者:=都可
set @用户变量名=值
set @用户变量名：=值

select必须用：=
select @用户变量名：=值


2. 赋值（更新用户变量的值）：
方式一:
set @用户变量名=值
set @用户变量名：=值

select必须用：=
select @用户变量名：=值


方式二:
通过select into
select 字段 into @变量名 from 表;

set @count = 1;
如select count(*) into @count from employees;



3. 使用（查看用户变量的值）
select @用户变量名;

如select @count;




局部变量
# ===================================================================================

作用域：begin end 中，应用在begin end中第一句话


1. 声明并初始化
declare 变量名 类型 default 值;


2. 赋值（更新用户变量的值）：
方式一:
set 局部变量名=值
set 局部变量名：=值 # 不需要加@

select必须用：=
select @用户变量名：=值 #select要加上@


方式二:
通过select into
select 字段 into 局部变量名 from 表;


3. 使用（查看用户变量的值）
select 用户变量名;



案例：
声明两个变量并赋初始值，求和，并打印

1. 用户变量
set @m=1;
set @n=2;
set @sum = @m+@n;
select @sum;


2. 局部变量
在begin end中加入下面语句
declare m int default 1;
declare n int default 2;
declare sum int;
set sum = m + n;
select sum;





存储过程和函数
# ===================================================================================

存储过程和函数类似于java的方法


存储过程的好处：
提高代码重用性，简化代码操作
减少编译次数
减少和数据库服务器的连接次数，提高了效率


存储过程：
一组预先编译好的sql语句的集合，可理解成批量处理语句
调用一个名字即可，不暴露里面内容



存储过程的语法：
创建，调用语法

create procedure 存储过程名字 （参数列表）
begin
    存储过程体（一组合法的sql语句）
end


参数列表包含三部分：
参数模式，参数名，参数类型
in stuname varchar(20)


参数模式：
in：该参数可以作为输入，也就是该参数需要调用方传入值
out：该参数可以作为输出，该参数可以作为返回值
inout：该参数可以作为输入，又可作为输出，也就是该参数既需要传入值，又可以返回值


begin end
存储过程体（一组合法的sql语句）只有一句话，begin end可省略

存储过程体中每条sql语句结尾必须加分号

存储过程的结尾可以使用delimiter重新设置

语法：
delimiter + 结束标记
如delimiter $



调用语法：
call 存储过程名（实参列表）;





空参的存储过程
# ===================================================================================

1. 空参列表
case：插入到admin表5条记录

select * from admin;


delimiter $
create procedure myp1() # 无参数
begin
    insert into admin(username,password) values("alice","12345"),
    ("alice","12345"),("alice","12345"),("alice","12345"),("alice","12345");
end $ 


在cmd里查看和输入指令


调用
call myp1()$





带in模式的存储过程
# ===================================================================================

案例一：

create procedure myp2(in beautyname varchar(20)) # beautyname是局部变量
begin
    select bo.* from boys bo
    right join beauty b on bo.id = b.boy_friend_id
    where b.name = beautyname;
end $ 


调用
call myp2("小昭")$

set names gbk$


查看视频另外例子



带out模式的存储过程
# ===================================================================================

create procedure myp5(in beautyname varchar(20), out boyname varchar(20))

begin
    select bo.boyname
    from boy bo
    inner join beauty b on bo.id = boy_friend_id
    where b.name = beautyname;
end$



调用

set@bname$
call myp5("小昭",@bname)$
select @name$


查看视频另外例子






带inout模式的存储过程
# ===================================================================================


传入a和b两个值，最终a和b都翻倍返回

create procedure myp8(inout a int, inout b int)
begin
    set a = a*2;
    set b = b*2;
end $ 


调用

set @m=10$
set @n=20$
call myp8(@m,@n)
select @m,@n$




删除存储过程
# ===================================================================================


drop procedure 存储过程名称

drop procedure p1;

不可以一次删除多个




查看存储过程
# ===================================================================================

show create procedure myp2;


没有修改功能，要修改，只能删除再建



函数介绍
# ===================================================================================

函数和存储过程的区别

存储过程：可以有0个返回，也可以有多个返回，适合做批量插入，批量更新
函数：有且仅有一个返回，适合做处理数据后返回一个结果




函数创建和调用语法
# ===================================================================================

创建语法:

create function 函数名（参数列表） returns 返回类型
begin
    函数体
end


注意：参数列表包含两部分，参数名和参数类型

函数体肯定会有return语句，如果没有会报错

如果函数体中只有一句话，begin end可省略

使用delimiter语句设置结束标记



调用语法:

select 函数名 （参数列表）





函数创建和调用案例
# ===================================================================================

1. 无参，有返回

案例一：返回公司员工个数

create function myf1() returns int
begin
    declare c int default 0; # 定义变量
    select count(*) into c # 赋值
    from employees;
    return c;
end $


调用语法：
select myf1() $



2. 有参，有返回

案例一：
根据员工名，返回工资


create function myf2(empname varchar(20)) returns double
begin
    set @sal=0; #定义用户变量
    select salary into @sal #赋值
    from employees 
    where lastname = empname;
    return @sal;
end$



调用语法：
select myf2("alice") $




案例一：
根据部门名，返回该部门平均工资


create function myf3(deptname varchar(20)) returns double
begin
    declare sal double; #定义局部变量
    select avg(salary) into sal #赋值
    from employees e
    inner join departments d on e.department_id = d.department_id
    where d.department_name = deptname;
    return sal;
end$



调用语法：
select myf3("IT") $






函数的查看和删除
# ===================================================================================


查看函数

show create function myf3;

删除函数

drop function myf3;




创建函数案例
# ===================================================================================

创建函数，实现传入两个float，返回二者之和

create function test_fun1(num1 float, num2 float) returns float
begin
    declare result float default 0;
    set result = num1+num2;
    return result;
end $


调用
select test_fun1(1,2)$





流程控制结构
# ===================================================================================

三大类：
顺序结构：程序从上往下依次执行
分支结构：程序从多条路径选择一条执行
循环结构：程序在满足一定条件基础上，重复执行一段代码

如果一次插入五万行记录，就会用到循环结构了




分支结构
# ===================================================================================

if 函数

实现简单的双分支

select if(表达式一，表达式二，表达式三)

应用：可以用在任何地方




分支结构：case
# ===================================================================================


情况一：类似java中switch语句，一般用于实现等值判断

语法：
case 变量|表达式|字段
when 要判断的值 then 返回的值1或语句;
when 要判断的值 then 返回的值2或语句;
when 要判断的值 then 返回的值3或语句;
...
else 要返回的值n或语句;
end case;



情况二：类似java中多重if语句，一般用于实现区间判断


语法：
case 
when 要判断的条件一 then 返回的值1或语句; # 如果是语句，则end case，如果是值，则end
when 要判断的条件一 then 返回的值2或语句;
when 要判断的条件一 then 返回的值3或语句;
...
else 要返回的值n或语句;
end case;


特点：

可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，begin end中或外面

可以作为独立语句使用，只能放在begin end中

如果都不满足，返回null



案例一：

创建存储过程，根据传入的成绩，来显示等级

create procedure test_case(in score int)
begin
    case 
    when score >=90 and score <=100 then select "A";
    when score >=80 then select "B";
    when score >=70 then select "C";
    else select "D";
    end case;
end$


调用
call test_case(95) $





分支结构：if结构
# ===================================================================================

实现多重分支

语法：
if 条件1 then 语句1;
elseif 条件2 then 语句2;
...
else 语句n;


应用：
应用在begin end中


create function test_if(score int) returns char # char(1)里的1可省略
begin
    case 
    when score >=90 and score <=100 then return "A";
    when score >=80 then return "B";
    when score >=70 then return "C";
    else return "D";
    end if;
end$





循环结构
# ===================================================================================

循环结构一定要在begin end中

循环语句:
while, loop, repeat


循环控制语句：
iterate类似于continue，继续
leave类似于break，跳出


下面的语句中[标签]可省略optional


1. while语法：
先判断后执行


[标签:]while 循环条件 do
    循环体;
end while [标签];



2. loop语法：
可以用来模拟简单的死循环


[标签:]loop 循环体
end loop [标签];




3. repeat语法：
先执行后判断，至少执行一次，类似于do while


[标签:]repeat 循环体
until 结束循环的条件
end repeat [标签];





循环结构演示
# ===================================================================================

1. 批量插入到admin表

建procedure，不建function，因为没有返回

create procedure pro_while1(in insertcount int)
begin
    declare i int default 1;
    (a:)while i<=insertcount do
        insert into admin(username, password) values (concat("rose", i), "666");
        set i=i+1;
    end while(a);
end$

没有用到循环控制， (a:)和(a)是可省略的


调用语法：
call pro_while1(100)$




2. 批量插入到admin表，次数大于20，则停止，添加leave语句

把上例中admin table删了
truncate table admin$
drop procedure test_while1


create procedure test_while1(in insertcount int)
begin
    declare i int default 1;
    a:while i<=insertcount do
        insert into admin(username, password) values (concat("rose", i), "666");
        if i >=20, then leave a; # leave后面必须加名字
        end if;
        set i=i+1;
    end while a;
end$

用到了循环控制leave， a:和a是不可以省略的


调用语法：
call test_while1(100)$




3. 批量插入到admin表，只插入偶数次，添加iterate语句

把上例中admin table删了
truncate table admin$
drop procedure test_while1


create procedure test_while1(in insertcount int)
begin
    declare i int default 0;
    a:while i<=insertcount do
        set i=i+1;
        if mod(i,2) != 0 then iterate a;
        end if;
        insert into admin(username, password) values (concat("rose", i), "666");
    end while a;
end$

用到了循环控制continue， a:和a是不可以省略的


调用语法：
call test_while1(100)$





流程控制经典案例
# ===================================================================================

案例：
表stringcontent，其中字段id自增长，content varchar（20）
向该表出入指定个数的随机字符串

drop table if exists stringcontent;

create table stringcontent(
    id int primary key auto_increment,
    content varchar(20)
);


delimiter $
create procedure test_randstr_insert(in insertcount int)
begin
    declare i int default 1;
    declare str varchar(26) default "abcdefghijklmnopqrstuvwxyz"
    declare startindex int default 1; # 代表起始索引
    declare len int default 1; # 代表截取字符的长度
    while i<=insertcount do

        set len = floor(rand()*(20-startindex+1)+1); # 20因为content varchar最大是20
        set startindex = floor(rand()*26+1); # floor向下取整
        insert into stringcontent(content) values (substring(str, startindex, len));
        set i=i+1;
end$


调用语法：
call test_randstr_insert(10) $





总结
# ===================================================================================

可以想象有张表，里面是id， name， salary， departmentid的例子
表里的departmentid是另一个department表的foreign key


select + 列名
from + 表名
where + logical condition
group by + 列名
having + logical condition
order by + 列名


select distinct # unqiue value in a column


多个table不可以用逗号连在一起，要用join

like %a%


in的用法（类似或）

group by with aggregation function
aggregation function: count,distinct, min, max, avg, sum等


要用having 必须要和group by一起用


order by默认asc


inner join on - return records that exist in both tables, and exclude unmatched records
left join on - 左边全有，右边没有就是null
right join on
outer join on


union连接两个table，union是去重的（deduplicate）

select from 第一个表名
union
select from 第二个表名

两个select from行数必须相同

不想去重，用union all




