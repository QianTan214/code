
"""
首先，如果你还没有对yield有个初步认识，那么你先把yield看做return，
这个是直观的，它首先是个return，普通的return是什么意思，就是在程序中返回某个值，
返回之后程序就不再往下运行了。
看做return之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器），
好了，如果你对这些不明白的话，那先把yield看做return,然后直接看下面的程序，
你就会明白yield的全部意思了
"""

def foo():
    print("starting...")
    while True:
        res = yield 4
        print("res:",res)
g = foo()
print(next(g))
print("*"*20)
print(next(g))

"""
结果：
starting...
4
********************
res: None
4

"""


"""
我直接解释代码运行顺序，相当于代码单步调试：

1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，
而是先得到一个生成器g(相当于一个对象)

2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环

3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，
并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，

4.程序执行print("*"*20)，输出20个*

5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，
不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，
也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,

6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，
然后程序停止，print函数输出的4就是这次return出的4.

 

到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，
而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，
这一次的next开始的地方是接着上一次的next停止的地方执行的，
所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，
然后遇到yield后，return出要生成的数，此步就结束。

"""

"""
一个带有 yield 的函数就是一个 generator，它和普通函数不同，
生成一个 generator 看起来像函数调用，但不会执行任何函数代码，
直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。
虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，
并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。

yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，
比起用类的实例保存状态来计算下一个 next() 的值，不仅代码简洁，而且执行流程异常清晰。

"""